import { writeFileSync } from 'fs';
import { join } from 'path';

interface RouteData {
  filePath: string;
  routePath: string;
  params: { name: string; type: string; optional?: boolean; catchAll?: boolean; }[];
}

// src/generator.ts
// ... (rest of imports and interfaces) ...

export function generateRoutesFile(routes: RouteData[]) {
  const outputPath = join(process.cwd(), 'src', 'generated-routes.ts');
  let fileContent = `// This file is auto-generated by your-router-gen. Do not modify.\n\n`;
  fileContent += `/**
 * Type-safe route helpers generated from your file-based routing.
 * Use these functions for safe navigation and link creation.
 */\n`;

  fileContent += `export const Routes = {\n`;

  routes.forEach(route => {
    // Corrected routeName generation for dynamic segments
    const routeName = route.routePath === '/'
                      ? 'home'
                      : route.routePath
                          .replace(/^\//, '')              // Remove leading slash
                          .replace(/:([a-zA-Z0-9_]+)\*?/g, '$1') // Remove colons AND optional '*' from dynamic segments
                          .replace(/\//g, '.');            // Replace slashes with dots

    // ... (rest of the if/else logic for parameters) ...

    if (route.params.length > 0) {
      const paramList = route.params.map(p => {
        let paramType = p.type;
        if (p.catchAll) {
            paramType = 'string[]';
        }
        return `${p.name}${p.optional ? '?' : ''}: ${paramType}`;
      }).join(', ');

      let pathConstruction = route.routePath;
      route.params.forEach(p => {
          if (p.catchAll) {
              pathConstruction = pathConstruction.replace(`:${p.name}*`, `\${params.${p.name}?.join('/') || ''}`);
          } else {
              pathConstruction = pathConstruction.replace(`:${p.name}`, `\${params.${p.name}}`);
          }
      });

      // The key issue was here: routeName needed to be free of '*'
      fileContent += `  ${routeName}: (params${route.params.every(p => p.optional) ? '?' : ''}: { ${paramList} }) => \`${pathConstruction}\`,\n`;
    } else {
      fileContent += `  ${routeName}: () => "${route.routePath}",\n`;
    }
  });

  fileContent += `};\n\n`;

  fileContent += `/**
 * Union type of all generated route names.
 */\n`;
  fileContent += `export type RouteNames = keyof typeof Routes;\n\n`;
  fileContent += `/**
 * Union type of all generated route paths (the actual URL strings).
 */\n`;
  fileContent += `export type RoutePaths = ReturnType<typeof Routes[RouteNames]>;\n`;


  try {
    writeFileSync(outputPath, fileContent, 'utf-8');
    console.log(`\nSUCCESS: Generated routes file at: ${outputPath}`);
  } catch (error) {
    console.error(`\nERROR: Could not generate routes file: ${outputPath}`);
    if (error instanceof Error) {
      console.error(`Reason: ${error.message}`);
    } else {
      console.error(error);
    }
  }
}